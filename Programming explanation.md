- HTML семантика и BEM
- CSS
- JS
- React JS 
- Typescript
- SVG и XML 
- Next JS 
- Redux Toolkit, RTK Query, React Query
- SEO
- Тестирование
- Паттерны проектирования 
- Алгоритмы
- SOLID , DRY & KISS
- Git 
- Менеджеры пакетов
- Контейнеризация
- Мониторинг и логирование
- CI/CD
- Deploy
- Терминал и его команды
- Гибкие методологии разработки
- Архитектуры Frontend разработки
- Безопасность
- Backend: NodeJS (Express) + базы данных (по собранному плейлисту + дока)
- Mobile: ReactNative
- Soft Skills


# 1.   HTML семантика и BEM
##  HTML семантика и ее преимущества

**Семантический HTML**, он же семантическая разметка, подразумевает использование HTML-тегов, передающих смысл собственного содержимого, например, **_заголовки, навигация, разделы страницы, списки и абзацы_**.

**Преимущества :**

- **Чтобы сделать сайт доступным.** Зрячие пользователи могут без проблем с первого взгляда понять, где какая часть страницы находится — где заголовок, списки или изображения. Для незрячих или частично незрячих всё сложнее. Основной инструмент для просмотра сайтов не браузер, который отрисовывает страницу, а скринридер, который читает текст со страницы вслух. Этот инструмент «зачитывает» содержимое страницы, и семантическая структура помогает ему лучше определять, какой сейчас блок, а пользователю понимать, о чём идёт речь. Таким образом семантическая разметка помогает б_о_льшему количеству пользователей взаимодействовать с вашим сайтом. Например, наличие заголовков помогает незрячим в навигации по странице. У скринридеров есть функция навигации по заголовкам, что ускоряет знакомство с информацией на сайте.

- **Чтобы сайт был выше в поисковиках.** Компании, которые создают поисковики, не разглашают правила ранжирования, но известно, что наличие семантической разметки страниц помогает поисковым ботам лучше понимать, что находится на странице, и в зависимости от этого ранжировать сайты в поисковой выдаче.

### HTML5 `<section>` элемент

Элемент определяет раздел в документе.

Согласно документации : "раздел представляет собой тематическую группировку контента, обычно с заголовком". **Важно отметить, что данный тэг можем иметь в себе h1, даже если h1 уже есть на странице (он как бы конвертирует его в h2).**

Домашняя страница обычно может быть разделена на разделы для ознакомления, содержания и контактной информации.

### HTML5`<article>`  элемент

Элемент `<article>` определяет независимое, автономное содержимое.

Статья должна иметь смысл самостоятельно, и она должна быть возможность читать его независимо от остальной части веб-сайта.

Примеры того, где можно использовать элемент `<article>`:

- Сообщение на форуме
- Блоге
- Газетная статья
###### Важно отметить: вложение `<article>` в `<section>` невозможно!

### HTML5 `<header>` элемент

Элемент `<header>` задает заголовок для документа или раздела.

Элемент `<header>` должен использоваться в качестве контейнера для вступительного содержания.
В одном документе может быть несколько элементов `<header>`.

### HTML5 `<footer>` элемент

Элемент `<footer>` указывает нижний колонтитул для документа или раздела.

Элемент `<footer>` должен содержать сведения о содержащем его элементе.

Нижний колонтитул обычно содержит автора документа, информацию об авторском праве, ссылки на условия использования, контактные данные и т.д.

В одном документе может быть несколько элементов `<footer>`.

### HTML5 `<nav>` элемент
Элемент `<nav>` определяет набор навигационных ссылок.

##  Модели контента

![[Pasted image 20250110224840.png]]

Контентные модели состоят из следующих категорий: flow content (контент потока), metadata content (контент метаданных), phrasing content (текстовый контент), embedded content (встроенный контент), interactive content (интерактивный контент), heading content (контент, содержащий заголовки), sectioning content (контент, который представляет собой секции страницы).

Каждая категория в HTML 5 определяет элементы, которые в ней можно использовать. Из рисунка видно, что некоторые области категорий пересекаются. Это означает что некоторые HTML-элементы можно использовать в различных контентах. Когда один контент является частью другого контента, это означает что они имеют общие элементы. 
## BEM

**Блок, элемент, модификатор**

Концепции BEM основываются на том, что **за каждым элементом интерфейса скрывается блок, который в свою очередь может содержать элементы и модификаторы.**

Блок определяется как самостоятельный компонент, который имеет собственные свойства и функционал. Например, блок `<header>` содержит общую информацию и ссылки на различные страницы сайта.

Элемент является частью блока. Он отвечает за определенный функционал внутри блока. Например, элемент «logo» внутри блока `<header>`.

Модификатор позволяет изменять поведение или внешний вид блока или элемента. Например, модификатор «active» для элемента «menu-item» внутри блока «menu» указывает, что элемент является активным на текущей странице. 

**Блок: header -> Элемент: header__logo ->  Модификатор: header__logo--small**
## Источники:

1. https://html5css.ru/html/html5_semantic_elements.php , https://vc.ru/seo/958291-ponimanie-semanticheskoi-verstki-osnovy-i-vliyanie-na-seo - расшифровка использования основных семантических тэгов.
2. https://ru.hexlet.io/blog/posts/kak-pravilno-ispolzovat-semanticheskie-tegi-article-i-section-nyuansy-html5-i-dostupnosti-saytov - правильное использование `<section>` и `<article>`
3. [https://html.spec.whatwg.org/multipage/](https://html.spec.whatwg.org/multipage/) - дока HTML
4. https://ru.bem.info/methodology/html/ - дока BEM
5.  [https://validator.w3.org/](https://validator.w3.org/) - валидатор
6. https://schema.org/ - для сниппетов
7. Модель контента HTML5 - https://itchief.ru/html-and-css/content-models#modeli-kontenta-do-html-5



# 2.   CSS
##### В данном разделе приведу только ссылки на полезные источники по тематикам.

#### Препроцессоры:
https://tproger.ru/translations/complete-sass-guide - руководство по scss / sass
https://htmlacademy.ru/blog/css/css-preprocessor - обзор препроцессоров
#### Адаптивность:
https://developer.mozilla.org/ru/docs/Learn_web_development/Core/CSS_layout/Responsive_Design - подробное руководство по адаптивности 

#### Анимации:
https://doka.guide/css/animation/ - руководство по анимациям простым языком

#### Доступность:
https://developer.mozilla.org/ru/docs/Learn_web_development/Core/Accessibility - подробное руководство по доступности на любых девайсах

#### Этапы рендеринга и оптимизация производительности:

![[Снимок экрана 2025-03-23 в 14.33.29.png]]

https://developer.mozilla.org/ru/docs/Web/Performance- очень подробная статья по ключевым этапам рендеринга и практически по всем видам оптимизации 


# 3. JS

## USE STRICT

**Strict mode** предлагает множество преимуществ, делая ваш код более надежным и устойчивым к ошибкам:

- **Повышает безопасность кода:** Запрещает некоторые небезопасные действия, такие как использование глобальных переменных без объявления.
- **Облегчает отладку:** Превращает "тихие" ошибки в исключения, что упрощает их обнаружение и исправление.
- **Подготавливает код к будущим стандартам:** Запрещает использование устаревшего синтаксиса, который может быть удален в будущих версиях JavaScript.
- **Предотвращает распространенные ошибки:** Такие как случайное создание глобальных переменных или дублирование параметров функций.
### Основные отличия strict mode от обычного режима

В **strict mode**, JavaScript изменяет поведение некоторых своих аспектов:

- **Переменные должны быть объявлены:** Попытка использовать переменную без объявления приведет к ошибке.
- **Запрещено дублирование параметров функций:** Нельзя иметь два параметра с одинаковым именем.
- **Запрещено использование восьмеричных литералов:** Например, `var n = 023;` вызовет ошибку.
- **Ограничения на `eval` и `arguments`:** Использование этих идентификаторов в ролях переменных или параметров функций запрещено.
- **`this` в глобальных функциях возвращает `undefined`:** В обычном режиме `this` в глобальных функциях ссылается на глобальный объект.
- **Нельзя использовать setters и getters без определения свойств**.
-  **Запрет на использование некоторых зарезервированных слов**: implements, interface, let, package, private, protected, public, static, yield.
- **Запрет на использование with**.

### Источники:
https://habr.com/ru/companies/ruvds/articles/477284/ - статья с подробными примерами по каждому отличию.

## LET, VAR, CONST

#### Области видимости 

`let` и `const` имеют блочную область видимости, в то время как `var` - не имеют блочной области видимости, они ограничены, как минимум, телом функции.

#### Инициализации

##### Инициализация `var`

 Объявления переменных `var` производится в начале исполнения функции (или скрипта для глобальных переменных). Присвоение же происходит без всплытия. 
```
function sayHi() {
 alert(phrase); 
 var phrase = "Привет"; 
} 
sayHi();
```

Строка `var phrase = "Привет"` состоит из двух действий:

1. Объявление переменной `var`
2. Присвоение значения в переменную `=`.

Объявление переменной обрабатывается в начале выполнения функции («всплывает»), однако присвоение значения всегда происходит в той строке кода, где оно указано. Т.е. код выполняется по следующему сценарию:

```
function sayHi() {
 var phrase; // объявление переменной срабатывает вначале... 
 alert(phrase); // undefined 
 phrase = "Привет"; // присвоение - в момент, когда исполнится данная строка кода. 
} 
sayHi();
```

##### Инициализация `let` и  `const`

Данные переменные находятся в неинициализированном состоянии с момента входа в блок кода (или функцию). И остаются неинициализированной до соответствующего оператора `let` или `const`.

```
let x = 1; 

function func() { 
 console.log(x); // ReferenceError: Cannot access 'x' before initialization let   x = 2; 
 } 
 
func();
```

Другими словами, переменная технически существует, но не может быть использована до `let`.

Приведенный выше код демонстрирует это.
```
function func() { 
 // локальная переменная x известна движку с самого начала выполнения функции, 
 // но она является неинициализированной до let ("мёртвая зона") 
 // следовательно, ошибка 
 console.log(x); // ReferenceError: Cannot access 'x' before initialization let   x = 2; 
}
```


## ОБЛАСТИ ВИДИМОСТИ

**_Глобальная область видимости_** — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости. Переменные в глобальной области видимости называются глобальными переменными и доступны всем.

**_Блочная область видимости_** ограничена программным блоком, обозначенным при помощи `{` и `}`. Простейший пример такой области — это выражение внутри скобок

**_Функциональная область видимости_** — это область видимости в пределах тела функции. Можно сказать, что она ограничена `{` и `}` функции.

***Модульная область видимости*** — при использовании [ES-модулей](https://doka.guide/js/modules/#moduli-v-javascript) переменная, объявленная вне функций, будет доступна, но только в том же модуле, где она создана.

### Источники:
https://doka.guide/js/closures/ -  дока с конкретными примерами.


## ТИПЫ ДАННЫХ
### NUMBER

Число в JavaScript представлено в виде 64-битного формата [IEEE-754](https://ru.wikipedia.org/wiki/IEEE_754-1985). Формат хранит произвольное число в виде трёх значений: 1 бит на знак числа, 52 бита значения числа и ещё 11 бит местоположения точки. С таким подходом можно эффективно хранить значения в большом диапазоне от -(253 − 1) до 253 − 1.

Стандарт [IEEE-754](https://ru.wikipedia.org/wiki/IEEE_754-1985) определяет три специальных значения. Эти значения принадлежат типу `number`, но не работают, как обычные числа:

- бесконечность `Infinity`;
- минус бесконечность `-Infinity`;
- не число (not a number) `NaN`.

Значение `NaN` используется, чтобы сообщить об операции, результатом которой оказалось не число. `NaN` всегда не равно самому себе, поэтому чтобы проверить, что переменная не является `NaN`, можно воспользоваться Number.isNaN() или сравнить переменную с собой же.
### STRING
Строка сложно устроена внутри, несмотря на то, что это примитив. Визуально текст представляет собой последовательность символов.

Символ, который видно на экране хранится в компьютере как одно или несколько чисел, каждое такое число называют _юнитом_. Компьютер хранит таблицу в которой числу соответствует символ. Такие таблицы называют _кодировкой_.
### BOOLEAN

```
const falsy1 = Boolean(),
  falsy2 = Boolean(0),
  falsy3 = Boolean(null),
  falsy4 = Boolean(''),
  falsy5 = Boolean(false)
  
const truthy1 = Boolean(true),
  truthy2 = Boolean('true'),
  truthy3 = Boolean('false'),
  truthy4 = Boolean('Су Лин'),
  truthy5 = Boolean([]),
  truthy6 = Boolean({}),
  truthy7 = Boolean('0'),
  truthy8 = Boolean(' ')
```


### UNDEFINED

`undefined` обозначает, что значение по каким-то причинам ещё не установлено или неизвестно. В этом контексте его использует сам язык JavaScript.

В языке существует похожее примитивное значение [`null`](https://doka.guide/js/null-primitive/). Оно обозначает _намеренное_ отсутствие значения _объекта_. `undefined` и `null` можно легко спутать, потому что это близкие понятия. Различие состоит в том, что `null` обозначает _намеренное_ отсутствие значения _объекта_, а `undefined` — что переменной не задано, но эта переменная не объект.

### NULL

`null` обозначает понятия «отсутствует» или «значение неизвестно» у _объекта_. Оно всегда явно задаётся программистом, JavaScript автоматически не устанавливает его.

В JavaScript `null` используется только для обозначения конца цепочки прототипов, чтобы показать, что следующий прототип отсутствует.

🛠 Оператор `typeof` определяет тип `null` как `'object'`. Это происходит потому, что примитивное значение `null` обозначает объект, у которого в данный момент не определена структура.
### BIGINT

Тип большого целого `BigInt` — примитивный тип, который представляет целые числа больше 253-1. Эти числа уже не помещаются в стандартный [примитив «число»](https://doka.guide/js/number/).

Этот тип используют для работы с произвольно большими целыми числами: идентификаторами, криптографическими ключами и другими данными, где требуется высокая точность.

`BigInt` не сериализуется в [JSON](https://doka.guide/tools/json/), то есть не переводится в последовательность битов. Это усложняет использование данного типа данных в задачах взаимодействия с сервером.

Создать `BigInt` можно двумя способами.

1️⃣ Добавить суффикс `n` в конец записи числа:

`const biggy = 9997000254740991n`

2️⃣ Вызвать конструктор `BigInt`:

`const alsoBig = BigInt(9997000254999999)`
### SYMBOL

Символ (`Symbol`) — примитивный тип, значения которого создаются с помощью вызова функции `Symbol`. Каждый созданный символ уникален.

Символы могут использоваться в качестве имён свойств в объектах. Символьные свойства могут быть прочитаны только при прямом обращении и не видны при обычных операциях.

### Источники: 
https://doka.guide/js/ 

## ПРЕОБРАЗОВАНИЕ ТИПОВ

**Грубо говоря, всё, кроме пустой строки, нуля,  NaN, null и undefined — true**.

##### **Явное преобразование** - преобразование с помощью конструкторов типов, например, Number().

##### **Неявное преобразование**:

Вначале посмотрим на примитивы.

2. Интерпретатор приведёт примитивные значения к логическим, если мы используем `&&` или `||`.
3. К строке, если мы используем `+`, когда один из операндов — строка.
4. К числу, если:
    1. мы используем операторы сравнения `<`, `<=`, `>`, `>=`;
    2. используем арифметические операции `-`, `+` (за исключением пункта 2), `/`, `*`.
    3. используем унарный плюс: `+'2' === 2`;
    4. используем оператор [нестрогого сравнения](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F#%D0%A0%D0%B0%D0%B2%D0%BD%D0%BE) `==`.

Но примитивами дело не заканчивается, JavaScript также неявно приводит и не примитивные значения.

Интерпретатор приводит их к логическому, если мы используем `&&` или `||`. Объекты — всегда `true`.

С числом и строкой всё немного интереснее. Чтобы определить, к строке приводить значение или к числу, JavaScript смотрит, какой из двух методов (`valueOf()` и `toString()`) в текущем объекте объявлен.

5. Если перед нами не объект `Date`, то метод `valueOf()` вызывается, обычно, первым (если не сильно углубляться в [детали спецификации](http://es5.github.io/#x8.12.8)).
6. Если возвращённое после этого значение — это примитив, то возвращается оно.
7. Если нет, то вызывается другой метод (если `valueOf()` не вернул примитив, то вызывается `toString()` и наоборот).
8. Если после этого вернулся примитив, возвращается он.
9. Если даже после этого не вернулся примитив, то будет ошибка `Uncaught TypeError: Cannot convert object to primitive value`.

### Прикольные примеры: 

-  ``console.log(null + []);  // "null"``
-  ``console.log(null + null);  // 0``
-  ``console.log(undefined + undefined);  // NaN``

### Источники:
https://doka.guide/js/typecasting/ -  дока с конкретными примерами.
## ОПЕРАТОРЫ СРАВНЕНИЯ

##### **Сравнение строк**

Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.

Алгоритм сравнения двух строк довольно прост:

1. Сначала сравниваются первые символы строк.
2. Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
4. Сравнение продолжается, пока не закончится одна из строк.
5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

##### **Сравнение разных типов**

При сравнении значений разных типов JavaScript приводит каждое из них к числу.

##### **Cравнение с null и undefined**

При строгом равенстве `===` эти значения различны, так как различны их типы.

При нестрогом равенстве `==` эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.

! **При использовании математических операторов и других операторов сравнения `< > <= >=`** значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.

### Прикольные примеры: 

``alert( null > 0); // (1) false`` 
``alert( null == 0); // (1) false`` 
``alert( null >= 0); // (1) true`` 

С точки зрения математики это странно. Результат последнего сравнения говорит о том, что «`null` больше или равно нулю», тогда результат одного из сравнений выше должен быть `true`, но они оба ложны.

Причина в том, что нестрогое равенство и сравнения `> < >= <=` работают по-разному. Сравнения преобразуют `null` в число, рассматривая его как `0`. Поэтому выражение (3) `null >= 0` истинно, а `null > 0` ложно.

С другой стороны, для нестрогого равенства `==` значений `undefined` и `null` действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) `null == 0` ложно.

## ОПЕРАТОРЫ НУЛЕВОГО СЛИЯНИЯ И ПРИСВАИВАНИЯ

##### Оператор нулевого слияния

Так как он обрабатывает `null` и `undefined` одинаковым образом, то для этой статьи мы введём специальный термин. Для краткости будем говорить, что значение «определено», если оно не равняется ни `null`, ни `undefined`.

Результат выражения `a ?? b` будет следующим:

- если `a` определено, то `a`,
- если `a` не определено, то `b`.

##### Оператор нулевого слияния

Оператор `??=` присвоит `x` значение `y` только в том случае, если `x` _не определено_ (`null`/`undefined`).

## СБОРКА МУСОРА 

Основной концепцией управления памятью в JavaScript является принцип _достижимости_.

Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантировано находятся в памяти.

6. Существует базовое множество достижимых значений, которые не могут быть удалены.
    
    Например:
    
    - Выполняемая в данный момент функция, её локальные переменные и параметры.
    - Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.
    - Глобальные переменные.
    - (некоторые другие внутренние значения)
    
    Эти значения мы будем называть _корнями_.
    
7. Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
    
    Например, если в глобальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то _этот_ объект считается достижимым. И те, на которые он ссылается, тоже достижимы. Далее вы познакомитесь с подробными примерами на эту тему.

Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

- Сборщик мусора «помечает» (запоминает) все корневые объекты.
- Затем он идёт по ним и «помечает» все ссылки из них.
- Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
- …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
- Все непомеченные объекты удаляются.

Если по простому, пока на элемент есть ссылка, то он остается достижимым. **Важно отметить**, что если это дочерний элемент, то все его родители должны тоже иметь ссылки, так как если удалят ссылку на корневой элемент, все его дочерние элементы тоже будут очищены.

## ФУНКЦИИ - КОНСТРУКТОРЫ

- Функции-конструкторы или просто конструкторы, являются обычными функциями, но существует общепринятое соглашение именовать их с заглавной буквы.

- Функции-конструкторы следует вызывать только с помощью `new`. Такой вызов подразумевает создание пустого `this` в начале и возврат заполненного в конце. Если мы решим написать оператор **`return`** в функции-конструкторе, она вернет нам значение после **`return`**, а не `this` (при условии, что после `return` идет какое-то выражение).

## (WEAK)MAP И (WEAK)SET

`Map` – коллекция пар ключ-значение.
Отличия от обычного объекта `Object`:
- Что угодно может быть ключом, в том числе и объекты.
- Есть дополнительные методы, свойство `size`.

`Set` – коллекция уникальных значений, так называемое «множество».

**Важно помнить, что Map и Set возвращают объекты, исключение - метод `.entries()`**

`WeakMap` – это `Map`-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

`WeakSet` – это `Set`-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.

`WeakMap` и `WeakSet` используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в `WeakMap` или в `WeakSet`, то он будет удалён автоматически.

## CALL, APPLY,  BIND

Данные методы существуют для привязки контекста, если он потерялся или явно не объявлен. 

`call` и `apply`  привязывают контекст и сразу вызывают данную функцию, единственное отличие их в том, что первый принимает аргументы через запятую, а второй - массивом.

Метод `bind` возвращает «привязанный вариант» функции `func`, фиксируя контекст `this` и первые аргументы `arg1`, `arg2`…, если они заданы.

Обычно `bind` применяется для фиксации `this` в методе объекта, чтобы передать его в качестве колбэка. Например, для `setTimeout`.

Когда мы привязываем аргументы, такая функция называется «частично применённой» или «частичной».

```
function mul(a, b) {
	return a * b; 
} 

let triple = mul.bind(null, 3); 

alert( triple(3) ); // = mul(3, 3) = 9 
alert( triple(4) ); // = mul(3, 4) = 12 
alert( triple(5) ); // = mul(3, 5) = 15
```
## ПРОТОТИПНОЕ НАСЛЕДОВАНИЕ

#### `obj.__proto__`

Это свойство объекта, которое ссылается на его прототип. Каждому объекту в JavaScript автоматически присваивается свойство [[Prototype]], доступное через `__proto__`.
Использование: .`__proto__` используется для доступа к прототипу конкретного экземпляра объекта.

- В JavaScript объекты имеют специальное скрытое свойство `[[Prototype]]`, которое либо равно `null`, либо ссылается на другой объект. Мы можем использовать `obj.__proto__`  для доступа к нему .
- Если мы хотим прочитать свойство `obj` или вызвать метод, которого не существует у `obj`, тогда JavaScript попытается найти его в прототипе.
- Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
- Если мы вызываем `obj.method()`, а метод при этом взят из прототипа, то `this` всё равно ссылается на `obj`. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
- Цикл `for..in` перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта. Для получения только собственных свойств используй `obj.hasOwnProperty`
- При удалении свойства или метода из объекта, оно будет взято, при наличии, из прототипа. 
- Встроенный геттер/сеттер `__proto__` не безопасен, если мы хотим использовать _созданные пользователями_ ключи в объекте. Как минимум потому, что пользователь может ввести `"__proto__"` как ключ, от чего может возникнуть ошибка. Если повезёт – последствия будут лёгкими, но, вообще говоря, они непредсказуемы.

На данный момент, это уже устаревший синтаксис для работы с прототипами, лучше использовать такие методы как: 

- [Object.create(proto[, descriptors])](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create)– создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto`, и необязательными дескрипторами свойств `descriptors`.
- [Object.getPrototypeOf(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) – возвращает свойство `[[Prototype]]` объекта `obj`.
- [Object.setPrototypeOf(obj, proto)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) – устанавливает свойство `[[Prototype]]` объекта `obj` как `proto`.

### `obj.prototype`

Это свойство функции-конструктора, которое определяет объект, который будет использоваться в качестве прототипа для всех экземпляров, созданных с помощью этой функции.
Использование: `.prototype` используется для добавления методов и свойств, которые будут доступны всем экземплярам, созданным с помощью конструктора.

По сути, все методы и свойства конструкторов хранятся в `.prototype`, если движок не находит метод в одном прототипе, он идет выше по цепочке до самого `null`.

![[Pasted image 20250226083854.png]]

Для примитивов алгоритм аналогичен с одним нюансом, так как у них нет своих методов и свойств, их нужно обернуть в объекты-обертки, такие как:
 `Number.prototype`, `String.prototype`, `Boolean.prototype`. Только у значений `undefined` и `null` нет объектов-обёрток.

**Важно**: Встроенные прототипы могут быть изменены или дополнены новыми методами. Но не рекомендуется менять их. Единственная допустимая причина – это добавление нового метода из стандарта, который ещё не поддерживается движком JavaScript.

### Источники:
https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Advanced_JavaScript_objects/Object_prototypes- статья MDN
https://learn.javascript.ru/prototypes - статьи с доступными и понятными примерами

## КЛАССЫ

В объектно-ориентированном программировании _класс_ – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы). 

Класс технически является функцией (той, которую мы определяем как `constructor`), в то время как методы, геттеры и сеттеры записываются в `Class.prototype`.

### Наследование классов 

#### super(...)

**Конструкторы в наследуемых классах должны обязательно вызывать `super(...)`, и  делать это перед использованием `this`, так как :**

В JavaScript существует различие между «функцией-конструктором наследующего класса» и всеми остальными. В наследующем классе соответствующая функция-конструктор помечена специальным внутренним свойством `[[ConstructorKind]]:"derived"`.

Разница в следующем:

- Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его `this` .
- Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.

Если наследуемый класс не имеет конструктора, то `super(...)` вызывается автоматически. 

#### Инициализация полей

 Поле класса инициализируется:
 
- Перед конструктором для базового класса (который ничего не расширяет),
- Сразу после `super()` для производного класса.

### Статические свойства и методы

Статические свойства и методы в JavaScript используются для создания функциональности, которая принадлежит самому классу (или функции-конструктору), а не его экземплярам. Это позволяет организовать код более эффективно и избежать дублирования. Вот основные причины и примеры использования статических свойств и методов:

▎1. Общая функциональность

Статические методы могут быть использованы для создания утилитарных функций, которые не требуют создания экземпляра класса. Например, это может быть метод для валидации данных или метод, который возвращает некоторую информацию о классе.

```
class MathUtils {
	static add(a, b) {
		return a + b;
	}
}

console.log(MathUtils.add(5, 3)); // 8
```

▎2. Создание фабричных методов

Статические методы могут использоваться как фабричные методы для создания экземпляров класса с определенной логикой.

```
class Person {
    constructor(name) {
        this.name = name;
    }

    static createAnonymous() {
        return new Person('Anonymous');
    }
}

const anonymous = Person.createAnonymous();
console.log(anonymous.name); // "Anonymous"
```

▎3. Управление состоянием класса

Статические свойства могут использоваться для хранения состояния, которое относится ко всему классу, а не к отдельным экземплярам. Например, можно хранить количество созданных экземпляров класса.

```
class Counter {
    static count = 0;

    constructor() {
        Counter.count++;
    }

    static getCount() {
        return Counter.count;
    }
}

new Counter();
new Counter();
console.log(Counter.getCount()); // 2
```

### Приватные и защищённые методы и свойства

Для сокрытия внутреннего интерфейса мы используем защищённые или приватные свойства:

- Защищённые поля имеют префикс `_`. Это хорошо известное соглашение, не поддерживаемое на уровне языка. Программисты должны обращаться к полю, начинающемуся с `_`, только из его класса и классов, унаследованных от него.
- Приватные поля имеют префикс `#`. JavaScript гарантирует, что мы можем получить доступ к таким полям только внутри класса.

### Примеси

_Примесь_ – общий термин в объектно-ориентированном программировании: класс, который содержит в себе методы для других классов.

Некоторые другие языки допускают множественное наследование. JavaScript не поддерживает множественное наследование, но с помощью примесей мы можем реализовать нечто похожее, скопировав методы в прототип.

Мы можем использовать примеси для расширения функциональности классов, например, для обработки событий. Например: 

```
let sayMixin = { 
	say(phrase) { 
		alert(phrase); 
	} 
}; 

let sayHiMixin = {
	__proto__: sayMixin, 
	sayHi() { 
		super.say(`Привет, ${this.name}`); // (*) 
	}, 
	sayBye() { 
		super.say(`Пока, ${this.name}`); // (*) 
	} 
}; 

class User { 
	constructor(name) { 
		this.name = name; 
	} 
} 

// копируем методы Object.assign(User.prototype, sayHiMixin); 

new User("Вася").sayHi(); // Привет, Вася!
```

## Обработка ошибок

Для обработки ошибок используем `try...catch...finally`

Важно помнить, что код в `try` должен быть _синтаксически верным_. Если написать невалидный код (например, не закрыть фигурные скобки), то скрипт не запустится, потому что JavaScript не поймёт код. Ошибки, которые обработает блок `catch`, будут ошибками во время выполнения программы.

Конструкция `finally`  отработает при любом случае, даже когда в `try` будет `return` или `catch` выкинет ошибку. 

### Источники: 

https://doka.guide/js/try-catch/ - дока с примерами.

https://medium.com/nuances-of-programming/обрабатываем-ошибки-в-react-полное-руководство-17a520b83ea9 - статья обработок ошибок в React

## ПРОМИСЫ

Промис  - это по сути объект-обертка (Proxy) над асинхронным кодом, которая помогает удобно с ним работать.

Вызывается промис через конструктор: 
```
let promise = new Promise(function(resolve, reject) {executor});
promise
.then(f1,f2) // f1 вызовется, если будет resolve(), f2 - reject()
.catch(e => console.log(e)) // будет вызван при ошибке
.finally{...} // будет вызван при любом исходе
```

### Обработка ошибок 

Обработка происходит при помощи `.catch`. На практике `.catch` перехватывает все виды ошибок в промисах: будь то вызов `reject()` или ошибка, брошенная в обработчике при помощи `throw` . 

Если вообще не использовать обработку ошибок, то следует использовать обработчик события `unhandledrejection` (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».

**Важное примечание**: `.catch` работает только синхронно с `throw` , например.

```
new Promise(function(resolve, reject) {
	setTimeout(() => { 
// если использовать throw, ничего не произойдет, так как тут асинхронная функция
		throw new Error("Whoops!"); 
// если пользоваться reject, то catch успешно сработает
		reject("Whoops!"); 
	}, 1000); 
}).catch(alert);
```

### API

**Promise.all(...)**

Метод `Promise.all` принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.

Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.

Если любой из промисов завершится с ошибкой, то промис, возвращённый `Promise.all`, немедленно завершается с этой ошибкой.

**Promise.allSettled(...)**

Метод `Promise.allSettled` всегда ждёт завершения всех промисов. В массиве результатов будет

- `{status:"fulfilled", value:результат}` для успешных завершений,
- `{status:"rejected", reason:ошибка}` для ошибок.

Для некоторых браузеров понадобится полифил:

```
if(!Promise.allSettled) { 
	Promise.allSettled = function(promises) { 
		return Promise.all(promises.map(p => Promise.resolve(p).then(value => (
		{ status: 'fulfilled', value: value }),
		 error => ({ status: 'rejected', reason: error })))); 
	}; 
}
```

**Promise.race(...)**

Метод очень похож на `Promise.all`, но ждёт только первый _выполненный_ промис, из которого берёт результат (или ошибку). После этого все остальные промисы игнорируются.

**Promise.any(...)**

Метод очень похож на `Promise.race`, но ждёт только первый _успешно выполненный_ промис, из которого берёт результат. После этого все остальные промисы игнорируются.

Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с помощью `AggregateError` – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве `errors`.

**Promise.withResolvers(...)**

Метод возвращает объект, содержащий новый Promise объект и две функции для его разрешения или отклонения, соответствующие двум параметрам, переданным исполнителю конструктора `Promise(...)` : 
```
 let { promise, resolve, reject } = Promise.withResolvers(); // как только мы применяем resolve или reject, то в promise заприсывается результат и он либо завершается, либо отклоняется.
```
### Источники: 

MDN: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise


## Генераторы

Генератор – это специальная функция, которая может приостанавливать своё выполнение и возвращать в результате объект-итератор.


- Генераторы создаются при помощи функций-генераторов function* f(…) {…}.
- Внутри генераторов и только внутри них существует оператор yield.
- Внешний код и генератор обмениваются промежуточными результатами посредством вызовов next/yield, например:


```
function* gen() { 
 let ask1 = yield "2 + 2 = ?"; 
 alert(ask1); // выведет 4 из .next(4)
 let ask2 = yield "3 * 3 = ?" 
 alert(ask2); // выведет 9 из .next(9) 
} 

let generator = gen(); 
alert( generator.next().value ); // "2 + 2 = ?" 
alert( generator.next(4).value ); // "3 * 3 = ?" 
alert( generator.next(9).done ); // true```
```


- Генераторы могут вызывать в себе другие генераторы, например: 

```
function* jvmLangs() {
 yield 'kotlin' 
 yield 'scala' 
 yield 'closure' 
} 
function* getLangs() { 
 const isFavorite = yield 'java'; 
 if (isFavorite) { 
  yield* jvmLangs() 
 } else { 
  yield 'js'; 
 } 
 yield 'rust'; 
}
const generator = getLangs() 

generator.next() // { value: 'java', done: false } 
generator.next(true) // { value: 'kotlin', done: false } 
generator.next() // { value: 'scala', done: false } 
generator.next() // { value: 'closure', done: false } 
generator.next() // { value: 'rust', done: false }
```

- Генераторы могут быть асинхронными, они будут очень полезны для получения асинхронных данных порционно, например, получение списка из 30 коммитов по нажатию кнопки.
### API

.next() - получение данных генератора из ближайшего yield
.return(...) - завершает генератор (в поле value будет значение, которое мы передали аргументом)
.throw(...) - завершает генератор с ошибкой
break -  оператор в цикле, который завершает генератор, после чего его невозможно использовать повторно в новом цикле.

## PROXY & REFLECT 

**Прокси – это обёртка вокруг объекта, которая «по умолчанию» перенаправляет операции над ней на объект, но имеет возможность перехватывать их. Проксировать можно любой объект, включая классы и функции.

Прокси имеют некоторые ограничения:

- Встроенные объекты используют так называемые «внутренние слоты», доступ к которым нельзя проксировать.
- То же самое можно сказать и о приватных полях классов, так как они реализованы на основе слотов. То есть вызовы проксированных методов должны иметь оригинальный объект в качестве `this`, чтобы получить к ним доступ.
- Проверка объектов на строгое равенство `===` не может быть перехвачена.
- Производительность: конкретные показатели зависят от интерпретатора, но в целом получение свойства с помощью простейшего прокси занимает в несколько раз больше времени. В реальности это имеет значение только для некоторых «особо нагруженных» объектов.

[Reflect](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect) API создано как дополнение к [Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy). Для любой ловушки из `Proxy` существует метод в `Reflect` с теми же аргументами. Нам следует использовать его, если нужно перенаправить вызов на оригинальный объект.  Например: 
```
user = new Proxy(user, { 
	get(target, prop, receiver) { 
		alert(`GET ${prop}`);
		return Reflect.get(target, prop, receiver); // возварщает target[prop]
	}, 
	set(target, prop, val, receiver) { 
		alert(`SET ${prop}=${val}`); 
		return Reflect.set(target, prop, val, receiver); // записывает  target[prop] = value
	} 
});
```

**_Отключаемый_** (revocable) прокси – это прокси, который может быть отключён вызовом специальной функции.

Допустим, у нас есть какой-то ресурс, и мы бы хотели иметь возможность закрыть к нему доступ в любой момент.

```
let object = { 
	data: "Важные данные" 
}; 

let {proxy, revoke} = Proxy.revocable(object, {});
alert(proxy.data); // Важные данные 

revoke(); // прокси больше не работает (отключён) 

alert(proxy.data); // Ошибка
```
### Источники: 

MDN: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy, https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect

## КАРРИРОВАНИЕ

Каррирование – это трансформация, которая превращает вызов `f(a, b, c)` в `f(a)(b)(c)`. В JavaScript реализация обычно позволяет вызывать функцию обоими вариантами: либо нормально, либо возвращает частично применённую функцию, если количество аргументов недостаточно.

```
// Продвинутая реализация

// Если аргументов меньше,чем у функции, то возвращает обертку, которая добавляет аргумент в текущий стек

function curry(func) { 
	return function curried(...args) { 
		if (args.length >= func.length) {
			return func.apply(this, args); 
		} else { 
			return function(...args2) { 
				return curried.apply(this, args.concat(args2)); 
			} 
		} 
	}
}

// Базовая реализация

function curry(f) {
	return function(a) {
		return function(b) { 
			return f(a, b); 
		}
	}
}
```

## ПОБИТОВЫЕ ОПЕРАТОРЫ

- Бинарные побитовые операторы: `& | ^ << >> >>>`.
- Унарный побитовый оператор один: `~`.

Как правило, битовое представление числа используется для:

- Округления числа: `(12.34^0) = 12`.
- Проверки на равенство `-1`: `if (~n) { n не -1 }`.
- Упаковки нескольких битовых значений («флагов») в одно значение. Это экономит память и позволяет проверять наличие комбинации флагов одним оператором `&`.
- Других ситуаций, когда нужны битовые маски.

### Источники 
Очень подробная статься про операторы и битовые маски – https://learn.javascript.ru/bitwise-operators

## EVENT LOOP 

У нас есть 3 основные сущности, которые мы будем затрагивать
	1.`Call Stack`, который нам предоставляет движок JS, помимо стека он решает такие проблемы как: 
![[Pasted image 20250323143741.png]]
	2. Event loop - бесконечный цикл выполнения микро и макро тасков. **Он не является частью движков, он предоставляется средой (браузер, NodeJs)**
	3. Web API - браузерное апи, которое представляет, например, таймауты, слушатели событий и тд.

Алгоритм работы данных трех сущностей вместе следующий:
	1. В стек попадают и выполняются все синхронные задачи.
	2. Регистрируем какие-то обработчики и таймауты в `Web API` и заполняем очередь микротасков.
	3. После того как  `Web API` выполнило определенную задачу, она уходит в очередь макротасков.
	4. Далее в стек уходят и выполняются сначала все микрозадачи, потом одна макрозадача и так до тех пор, пока стек не будет опустошен.

Примерная схема: 
![[Снимок экрана 2025-03-23 в 14.33.05.png]]![[Pasted image 20250323145330.png]]

### Источники: 
MDN - https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Execution_model
Очень подробное видео про `event loop` и критические этапы рендера - https://www.youtube.com/watch?v=zDlg64fsQow&ab_channel=UlbiTV

## СЕТЕВЫЕ ЗАПРОСЫ

### Fetch 

```
let promise = fetch(url, [options])
```

`Options` - объект дополнительных опций, например: 

	1.Headers
	2.Method (POST,GET,PUT...)
	3.body (json,Blob,FormData,ArrayBuffer,text)
	4.mode (no-cors, *cors, same-origin)
	5.cache: (no-cache, no-cache, reload, force-cache, only-if-cached)
	6.credentials: (same-origin,include, omit)
	7.redirect: (follow,manual,error) 
	8.signal: (AbortController)

**Параметры ответа**:

- `response.status` – HTTP-код ответа,
- `response.ok` – `true`, если статус ответа в диапазоне 200-299.
- `response.headers` – похожий на `Map` объект с HTTP-заголовками.

**Методы для получения тела ответа**:

- **`response.text()`** – возвращает ответ как обычный текст,
- **`response.json()`** – декодирует ответ в формате JSON,
- **`response.formData()`** – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
- **`response.blob()`** – возвращает объект как [Blob](https://learn.javascript.ru/blob) (бинарные данные с типом),
- **`response.arrayBuffer()`** – возвращает ответ как [ArrayBuffer](https://learn.javascript.ru/arraybuffer-binary-arrays) (низкоуровневые бинарные данные)

#### Индикация загрузки 

Можно отслеживать индикацию загрузки в байтах при помощи `response.body.getReader()`.

**Есть один нюанс - если мы считываем данные из ответа способом ниже, то методы `.json() , .text()` и т.д. не будут работать.** 

Пример индикации и декодирования данных в строку :

```
// Шаг 1: начинаем загрузку fetch, получаем поток для чтения 
	let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100'); 
	const reader = response.body.getReader(); 
	
// Шаг 2: получаем длину содержимого ответа 
	const contentLength = +response.headers.get('Content-Length'); 
	
// Шаг 3: считываем данные: 
	let receivedLength = 0; // количество байт, полученных на данный момент 
	let chunks = []; // массив полученных двоичных фрагментов
	
	while(true) { 
		// done становится true в последнем фрагменте 
		// value - Uint8Array из байтов каждого фрагмента
		const {done, value} = await reader.read(); 
		
		if (done) { 
			break; 
		} 
		
		chunks.push(value); 
		receivedLength += value.length; 
		console.log(`Получено ${receivedLength} из ${contentLength}`) 
	} 
	
// Шаг 4: соединим фрагменты в общий типизированный массив Uint8Array 
	let chunksAll = new Uint8Array(receivedLength); 
	let position = 0; 
	for(let chunk of chunks) { 
		chunksAll.set(chunk, position);
		position += chunk.length; 
	} 
	
// Шаг 5: декодируем Uint8Array обратно в строку 
	let result = new TextDecoder("utf-8").decode(chunksAll);
	let commits = JSON.parse(result); alert(commits[0].author.login);
```

#### Прерывание запросов 

Осуществляется за счет `AbortController()`. 

```
let urls = [...]; // список URL для параллельных fetch 
let controller = new AbortController(); 
let fetchJobs = urls.map(url => fetch(url, { signal: controller.signal })); 
let results = await Promise.all(fetchJobs); 

// если откуда-то вызвать controller.abort(),то это прервёт все вызовы fetch
```

#### Запросы на другие сайты

С точки зрения браузера запросы к другому источнику бывают двух видов: «простые» и все остальные.

[Простые запросы](https://www.w3.org/TR/cors/#terminology) должны удовлетворять следующим условиям:

- Метод: GET, POST или HEAD.
- Заголовки – мы можем установить только:
    - `Accept`
    - `Accept-Language`
    - `Content-Language`
    - `Content-Type` со значением `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`.

Основное их отличие заключается в том, что простые запросы с давних времён выполнялись с использованием тегов `<form>` или `<script>`, в то время как непростые долгое время были невозможны для браузеров.

Практическая разница состоит в том, что простые запросы отправляются сразу с заголовком `Origin`, а для других браузер делает предварительный запрос, спрашивая разрешения.

**Для простых запросов:**

- → Браузер посылает заголовок `Origin` с источником.
- ← Для запросов без авторизационных данных (не отправляются по умолчанию) сервер должен установить:
    - `Access-Control-Allow-Origin` в `*` или то же значение, что и `Origin`
- ← Для запросов с авторизационными данными сервер должен установить:
    - `Access-Control-Allow-Origin` в то же значение, что и `Origin`
    - `Access-Control-Allow-Credentials` в `true`

Дополнительно, чтобы разрешить JavaScript доступ к любым заголовкам ответа, кроме `Cache-Control`, `Content-Language`, `Content-Type`, `Expires`, `Last-Modified` или `Pragma`, сервер должен перечислить разрешённые в заголовке `Access-Control-Expose-Headers`.

**Для непростых запросов перед основным запросом отправляется предзапрос:**

- → Браузер посылает запрос `OPTIONS` на тот же адрес с заголовками:
    - `Access-Control-Request-Method` – содержит запрашиваемый метод,
    - `Access-Control-Request-Headers` – перечисляет непростые запрашиваемые заголовки.
- ← Сервер должен ответить со статусом 200 и заголовками:
    - `Access-Control-Allow-Methods` со списком разрешённых методов,
    - `Access-Control-Allow-Headers` со списком разрешённых заголовков,
    - `Access-Control-Max-Age` с количеством секунд для кеширования разрешений
- → Затем отправляется основной запрос, применяется предыдущая «простая» схема.

### WebSocket && Server Send Events

Оба этих классов реализуют постоянное соединение с сервером, но есть несколько отличий: 

| WebSocket                                                            | Server Send Events                                |
| -------------------------------------------------------------------- | ------------------------------------------------- |
| Двунаправленность: и сервер, и клиент могут обмениваться сообщениями | Однонаправленность: данные посылает только сервер |
| Бинарные и текстовые данные                                          | Только текст                                      |
| Протокол WebSocket                                                   | Обычный HTTP                                      |
| Нет автоматического переподключения                                  | Есть автоматическое переподключение               |

По сути, `Server Send Events` проще в реализации, поэтому для чего-то не особо сложно, рекомендуется использовать его. `WebSocket` же более низкоуровневый и поддерживает более продвинутый функционал.

### Источники
LearnJS - https://learn.javascript.ru/network
MDN - https://developer.mozilla.org/ru/docs/Web/API/Fetch_API/Using_Fetch

## ХРАНЕНИЕ ДАННЫХ В БРАУЗЕРЕ

### Cookie

`document.cookie` предоставляет доступ к куки.

- Операция записи изменяет только то куки, которое было указано.
- Имя и значение куки должны быть закодированы.
- Одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).

Настройки куки:

- `path=/`, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
- `domain=site.com`, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
- `expires` или `max-age` устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.
- `secure` делает куки доступным только при использовании HTTPS.
- `samesite` запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.

Дополнительно:

- Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.
- Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR.
### Local & Session Storage

 Объекты веб-хранилища `localStorage` и `sessionStorage` позволяют хранить пары ключ/значение в браузере.

 Отличия от `cookie` :
 - Объекты веб-хранилища не отправляются на сервер при каждом запросе. Именно поэтому мы можем хранить гораздо больше данных. Большинство современных браузеров могут выделить как минимум 5 мегабайтов данных (или больше), и этот размер можно поменять в настройках.
- Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
- Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.
- Данные не имеют «времени истечения».

| localStorage                                                                  | sessionStorage                                                             |
| ----------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| Совместно используется между всеми вкладками и окнами с одинаковым источником | Разделяется в рамках вкладки браузера, среди ифреймов из того же источника |
| «Переживает» перезапуск браузера                                              | «Переживает» перезагрузку страницы (но не закрытие вкладки)                |
### IndexedDB

IndexedDB можно рассматривать как «localStorage на стероидах». Это простая база данных типа ключ-значение, достаточно мощная для оффлайн приложений, но простая в использовании.

Лучшим руководством является спецификация, [текущая версия 2.0](https://w3c.github.io/IndexedDB), но также поддерживаются несколько методов из [3.0](https://w3c.github.io/IndexedDB/) (не так много отличий) версии.

Использование можно описать в нескольких фразах:

1. Подключить обёртку над промисами, например [idb](https://github.com/jakearchibald/idb).
2. Открыть базу данных: `idb.openDb(name, version, onupgradeneeded)`
    - Создайте хранилища объектов и индексы в обработчике `onupgradeneeded` или выполните обновление версии, если это необходимо
3. Для запросов:
    - Создать транзакцию `db.transaction('books')` (можно указать readwrite, если надо).
    - Получить хранилище объектов `transaction.objectStore('books')`.
4. Затем для поиска по ключу вызываем методы непосредственно у хранилища объектов.
    - Для поиска по любому полю объекта создайте индекс.
5. Если данные не помещаются в памяти, то используйте курсор (функция, которая отдает данные порционно, что занимает меньше памяти).
### Источники 
LearnJS - https://learn.javascript.ru/data-storage